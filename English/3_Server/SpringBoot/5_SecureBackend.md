[Back](README.md)

## Secure Backend

<hr>


### 1. What is Spring Security

> Spring Security (https://spring.io/projects/spring-security) provides security services for Java-based web applications.

By default, Spring Security enables the following features:
    

- AuthenticationManager bean(an in-memory single user)
    > The username is user and the password is printed to the console output

- Ignored paths for common static resource locations
    > eg: /css and /images

- HTTP basic authentication for all other endpoints
    > A default autogenerated login page

- Security events published to Spring’s ApplicationEventPublisher interface

- Common low-level features turned on by default
    > HTTP Strict Transport Security (HSTS), cross-site scripting (XSS), and cross-site request forgery (CSRF)

&nbsp;

### 2. Add Spring Security

2-1) add dependencies in build.gradle

```groovy
dependencies {
	...
	implementation 'org.springframework.boot:spring-boot-starter-security'
	...
	testImplementation 'org.springframework.security:spring-security-test'
}
```

<hr>

2-2) start your application

You can see from the console that Spring Security has created an in-memory user with a username of user. The user’s password can be seen in the console output.

<hr>

2-3) Check


Open your web browser and navigate to http://localhost:8080/api. You will be redirected to the Spring Security default login page(with username and password).

Type user into the Username field and copy the generated password from the console to the Password field. With authentication, we can see that the response contains our API resources.

&nbsp;

### 3. Customize Spring Security(basic authentication)

To configure how Spring Security behaves, we have to add a new configuration class for Spring Security. You can also define the authentication mechanism, the login 
process, session management, and so on.

3-1) Create a new class called SecurityConfig in your application root package

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
@Configuration
@EnableWebSecurity
public class SecurityConfig {
}
```

<hr>

3-2) Add in-memory users to our application by using Spring Security’s 
InMemoryUserDetailsManager

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
	@Bean
	public InMemoryUserDetailsManager userDetailsService() {
	UserDetails user = User.builder().username("user")
		.password(passwordEncoder().encode("password"))
		.roles("USER").build();
		return new InMemoryUserDetailsManager(user);
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
}
```

&nbsp;

### 4. Save users to the database

To save users to the database, you have to create a user entity class and repository.

_Passwords shouldn’t be saved to the database in plaintext format. If a database containing user passwords is hacked, attackers will be able to get the passwords directly in plaintext. Spring Security provides multiple hashing algorithms, such as bcrypt, that you can use to hash passwords._

4-1) Create entity class

AppUser.java
```java
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class AppUser {
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(nullable = false, updatable = false)
	private Long id;
	@Column(nullable = false, unique = true)
	private String username;
	@Column(nullable = false)
	private String password;
	@Column(nullable = false)
	private String role;

	public AppUser() {
	}

	public AppUser(String username, String password, String role) {
		super();
		this.username = username;
		this.password = password;
		this.role = role;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getRole() {
		return role;
	}

	public void setRole(String role) {
		this.role = role;
	}
}
```

<hr>

4-2) Create repository class

AppUserRepository.java
```java
import java.util.Optional;

import org.springframework.data.repository.CrudRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(exported = false)
public interface AppUserRepository extends CrudRepository<AppUser, Long> {
	Optional<AppUser> findByUsername(String username);
}
```

<hr>

4-3) Create service implementation

UserDetailsServiceImpl.java
```java
import java.util.Optional;
import org.springframework.security.core.userdetails.User.UserBuilder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import com.packt.cardatabase.domain.AppUser;
import com.packt.cardatabase.domain.AppUserRepository;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
	private final AppUserRepository repository;

	public UserDetailsServiceImpl(AppUserRepository repository) {
		this.repository = repository;
	}

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		Optional<AppUser> user = repository.findByUsername(username);
		UserBuilder builder = null;
		if (user.isPresent()) {
			AppUser currentUser = user.get();
			builder = org.springframework.security.core.userdetails.User.withUsername(username);
			builder.password(currentUser.getPassword());
			builder.roles(currentUser.getRole());
		} else {
			throw new UsernameNotFoundException("User not found.");
		}
		return builder.build();
	}
}
```

<hr>

4-4) Define a password hashing algorithm in the configureGlobal method of SecurityConfig class

SecurityConfig.java
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
	private final UserDetailsServiceImpl userDetailsService;

	public SecurityConfig(UserDetailsServiceImpl userDetailsService) {
		this.userDetailsService = userDetailsService;
	}

	public void configureGlobal(AuthenticationManagerBuilder auth) 
        throws Exception {
		auth.userDetailsService(userDetailsService).passwordEncoder(
            new BCryptPasswordEncoder());
	}
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
```

<hr>

4-5) Save a couple of test users to the database using the CommandLineRunner


CardatabaseApplication.java
```java
@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {
	private final AppUserRepository userRepository;

	public CardatabaseApplication(AppUserRepository userRepository) {
		this.userRepository = userRepository;
	}

	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		...

		// Username: user, password: user
		userRepository.save(
            new AppUser("user", "$2a$10$NVM0n8ElaRgg7zWO1CxUdei7vWoPg91Lz2aYavh9.f9q0e4bRadue", "USER"));
		// Username: admin, password: admin
		userRepository.save(
            new AppUser("admin","$2a$10$8cjz47bjbR4Mn8GMg9IZx.vyjhLXR/SKKMSZ9.mP9vpMu0ssKi8GW", "ADMIN"));
	}
}
```

<hr>

4-6) Check

Now you will get a 401 Unauthorized error if you try to send a GET request to the http://localhost:8080/api path without authentication. 
You must authenticate to be able to send a successful request.

Use basic auth in header, input username and password
![basic auth of spring security](https://github.com/Elliot518/mcp-oss-repo/blob/main/backend/springsecurity/basic_auth.png?raw=true)

&nbsp;

### 5. Securing backend with JWT

- Drawbacks of basic authentication 

	It doesn’t provide a way to handle tokens or manage sessions. When a user logs 
	in, the credentials are sent with each request, which can cause session management challenges and potential security risks.

<hr>

-  JSON Web Token (JWT)

	> JWTs (https://jwt.io/) are commonly used in RESTful APIs for authentication and authorization purposes. They are a compact way to implement authentication in modern web applications. A JWT is really small in size and can therefore be sent in the URL, in the POST parameter, or inside the header. It also contains all the necessary information about the user, such as their username and role.

	- Elements of JWT
	
		1. Header: The first part is the header, which defines the type of token and the hashing algorithm

		2. Payload: The second part is the payload, which, typically, in the case of authentication, contains user information

		3. Signature: The third part is the signature, which is used to verify that the token hasn’t been changed along the way

	_(eg: Header.Payload.Signature)_

#### How to implement JWT in SpringBoot

#### 5-1) add jwt dependencies

build.gradle
```groovy
dependencies {
	...
	implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
	runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5', 'io.jsonwebtoken:jjwt-jackson:0.11.5'
}
```

_We will use jjwt (https://github.com/jwtk/jjwt), which is the JWT library for Java and Android for creating and parsing JWTs._


<hr>

#### 5-2) create a class that generates and verifies a signed JWT

JwtService.java
```java
import org.springframework.stereotype.Component;

@Component
public class JwtService {
	// 1 day in ms. Should be shorter in production
	static final long EXPIRATIONTIME = 86400000; 
	
	static final String PREFIX = "Bearer";
}
```

A JWT is sent in the Authorization header and the content of the header looks like the following when using the Bearer schema:
```json
Authorization: Bearer <token>
```

<hr>

#### 5-3) create a secret key using the jjwt library’s secretKeyFor method


_This is only for demonstration purposes. In a production environment, you should read your secret key from the application configuration._



```java
/**
	The getToken method then generates and returns the token. The getAuthUser method gets the token from the response Authorization header. 
	Then, we will use the parserBuilder method provided by the jjwt library to create a JwtParserBuilder instance. The setSigningKey method is used to specify a secret key for token verification. The parseClaimsJws method removes the Bearer prefix from the Authorization header. Finally, we will use the getSubject method to get the username.
 */
public class JwtService {
	...

	// Generate secret key. Only for demonstration purposes.
 	// In production, you should read it from the application configuration.
 	static final Key key = Keys.secretKeyFor (SignatureAlgorithm.HS256);

 	// Generate signed JWT token
	public String getToken(String username) {
		String token = Jwts.builder()
			.setSubject(username)
			.setExpiration(new Date(System.currentTimeMillis() +
			EXPIRATIONTIME))
			.signWith(key)
			.compact(); 
	
		return token;
	}

	// Get a token from request Authorization header,
	// verify the token, and get username
	public String getAuthUser(HttpServletRequest request) {
		String token = request.getHeader(HttpHeaders.AUTHORIZATION);

		if (token != null) {
			String user = Jwts.parserBuilder()
				.setSigningKey(key)
				.build()
				.parseClaimsJws(token.replace(PREFIX, ""))
				.getBody()
				.getSubject();

			if (user != null)
				return user;
		}

		return null;
	}
}
```

<hr>

#### 5-4) add a new class to store credentials for authentication

_We can use a Java record, which was introduced in Java 14. A record is a good choice if you need a class that only holds data.The record has two fields: username and password, and we don’t have to write getters and setters when using it._
```java
public record AccountCredentials(String username, String password) 
{}
```

<hr>

#### 5-5) implement the controller class for login

_Login is done by calling the /login endpoint using the POST method and sending the username and password inside the request body._

LoginController.java
```java
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import com.packt.cardatabase.domain.AccountCredentials;
import com.packt.cardatabase.service.JwtService;

@RestController
public class LoginController {
	private final JwtService jwtService;
	private final AuthenticationManager authenticationManager;

	public LoginController(JwtService jwtService, AuthenticationManager authenticationManager) {
		this.jwtService = jwtService;
		this.authenticationManager = authenticationManager;
	}

	@PostMapping("/login")
	public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {
		// Generate token and send it in the response Authorization
		// header
	}
}
```

<hr>

#### implement the getToken method that handles the login functionality

```java
/*
	Get a JSON object from the request body that contains the username and password. 
	AuthenticationManager is used to perform authentication and it uses credentials that 
	we get from the request. 
	Then, we use the JwtService class’ getToken method to generate a JWT. 
	Finally, we build an HTTP response that contains the generated JWT in the Authorization header
*/
@PostMapping("/login")
public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {
	UsernamePasswordAuthenticationToken creds = new UsernamePasswordAuthenticationToken(
		credentials.username(), credentials.password());
	Authentication auth = authenticationManager.authenticate(creds);

	// Generate token
	String jwts = jwtService.getToken(auth.getName());

	// Build response with the generated token
	return ResponseEntity.ok().header(HttpHeaders.AUTHORIZATION, "Bearer" + jwts)
		.header(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS,"Authorization").build();
}
```


<hr>

#### 5-6) add AuthenticationManager in  SecurityConfig class

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;

...

@Configuration
@EnableWebSecurity
public class SecurityConfig {

	...


	@Bean
	public AuthenticationManager uthenticationManager(AuthenticationConfiguration authConfig) 
		throws Exception {
		return authConfig.getAuthenticationManager();
	}
 }
```

<hr>

#### 5-7) Add the filterChain method to the SecurityConfig class

> Spring Security’s SecurityFilterChain bean defines which paths are secured and which are not.

- eg: POST method request to the /login endpoint is allowed without authentication 
and that requests to all other endpoints require authentication
	```java
	// SecurityConfig.java
	// Add the following import
	import org.springframework.security.web.SecurityFilterChain;

	// Add filterChain method
	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) 
		throws Exception {
		http.csrf((csrf) -> csrf.disable())
			.sessionManagement((sessionManagement) -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
			.authorizeHttpRequests((authorizeHttpRequests) -> authorizeHttpRequests.requestMatchers(HttpMethod.POST,
			"/login").permitAll().anyRequest().authenticated());
		
		return http.build();
	}
	```

	_PS: We define that Spring Security will never create a session, and therefore we can disable cross-site request forgery (csrf). JWTs are designed to be stateless, which reduces the risk of session-related vulnerabilities._

<hr>

#### 5-8) Test login functionality

