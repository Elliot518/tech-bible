[Back](README.md)

## Secure Backend

<hr>


### 1. What is Spring Security

> Spring Security (https://spring.io/projects/spring-security) provides security services for Java-based web applications.

By default, Spring Security enables the following features:
    

- AuthenticationManager bean(an in-memory single user)
    > The username is user and the password is printed to the console output

- Ignored paths for common static resource locations
    > eg: /css and /images

- HTTP basic authentication for all other endpoints
    > A default autogenerated login page

- Security events published to Spring’s ApplicationEventPublisher interface

- Common low-level features turned on by default
    > HTTP Strict Transport Security (HSTS), cross-site scripting (XSS), and cross-site request forgery (CSRF)

&nbsp;

### 2. Add Spring Security

2-1) add dependencies in build.gradle

```groovy
dependencies {
	...
	implementation 'org.springframework.boot:spring-boot-starter-security'
	...
	testImplementation 'org.springframework.security:spring-security-test'
}
```

<hr>

2-2) start your application

You can see from the console that Spring Security has created an in-memory user with a username of user. The user’s password can be seen in the console output.

<hr>

2-3) Check


Open your web browser and navigate to http://localhost:8080/api. You will be redirected to the Spring Security default login page(with username and password).

Type user into the Username field and copy the generated password from the console to the Password field. With authentication, we can see that the response contains our API resources.

&nbsp;

### 3. Customize Spring Security(basic authentication)

To configure how Spring Security behaves, we have to add a new configuration class for Spring Security. You can also define the authentication mechanism, the login 
process, session management, and so on.

3-1) Create a new class called SecurityConfig in your application root package

```java
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
@Configuration
@EnableWebSecurity
public class SecurityConfig {
}
```

<hr>

3-2) Add in-memory users to our application by using Spring Security’s 
InMemoryUserDetailsManager

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
	@Bean
	public InMemoryUserDetailsManager userDetailsService() {
	UserDetails user = User.builder().username("user")
		.password(passwordEncoder().encode("password"))
		.roles("USER").build();
		return new InMemoryUserDetailsManager(user);
	}

	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
}
```

&nbsp;

### 4. Save users to the database

To save users to the database, you have to create a user entity class and repository.

_Passwords shouldn’t be saved to the database in plaintext format. If a database containing user passwords is hacked, attackers will be able to get the passwords directly in plaintext. Spring Security provides multiple hashing algorithms, such as bcrypt, that you can use to hash passwords._

4-1) Create entity class

AppUser.java
```java
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;

@Entity
public class AppUser {
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(nullable = false, updatable = false)
	private Long id;
	@Column(nullable = false, unique = true)
	private String username;
	@Column(nullable = false)
	private String password;
	@Column(nullable = false)
	private String role;

	public AppUser() {
	}

	public AppUser(String username, String password, String role) {
		super();
		this.username = username;
		this.password = password;
		this.role = role;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getUsername() {
		return username;
	}

	public void setUsername(String username) {
		this.username = username;
	}

	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	public String getRole() {
		return role;
	}

	public void setRole(String role) {
		this.role = role;
	}
}
```

<hr>

4-2) Create repository class

AppUserRepository.java
```java
import java.util.Optional;

import org.springframework.data.repository.CrudRepository;
import org.springframework.data.rest.core.annotation.RepositoryRestResource;

@RepositoryRestResource(exported = false)
public interface AppUserRepository extends CrudRepository<AppUser, Long> {
	Optional<AppUser> findByUsername(String username);
}
```

<hr>

4-3) Create service implementation

UserDetailsServiceImpl.java
```java
import java.util.Optional;
import org.springframework.security.core.userdetails.User.UserBuilder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import com.packt.cardatabase.domain.AppUser;
import com.packt.cardatabase.domain.AppUserRepository;

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
	private final AppUserRepository repository;

	public UserDetailsServiceImpl(AppUserRepository repository) {
		this.repository = repository;
	}

	@Override
	public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
		Optional<AppUser> user = repository.findByUsername(username);
		UserBuilder builder = null;
		if (user.isPresent()) {
			AppUser currentUser = user.get();
			builder = org.springframework.security.core.userdetails.User.withUsername(username);
			builder.password(currentUser.getPassword());
			builder.roles(currentUser.getRole());
		} else {
			throw new UsernameNotFoundException("User not found.");
		}
		return builder.build();
	}
}
```

<hr>

4-4) Define a password hashing algorithm in the configureGlobal method of SecurityConfig class

SecurityConfig.java
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
	private final UserDetailsServiceImpl userDetailsService;

	public SecurityConfig(UserDetailsServiceImpl userDetailsService) {
		this.userDetailsService = userDetailsService;
	}

	public void configureGlobal(AuthenticationManagerBuilder auth) 
        throws Exception {
		auth.userDetailsService(userDetailsService).passwordEncoder(
            new BCryptPasswordEncoder());
	}
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
```

<hr>

4-5) Save a couple of test users to the database using the CommandLineRunner


CardatabaseApplication.java
```java
@SpringBootApplication
public class CardatabaseApplication implements CommandLineRunner {
	private final AppUserRepository userRepository;

	public CardatabaseApplication(AppUserRepository userRepository) {
		this.userRepository = userRepository;
	}

	public static void main(String[] args) {
		SpringApplication.run(CardatabaseApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		...

		// Username: user, password: user
		userRepository.save(
            new AppUser("user", "$2a$10$NVM0n8ElaRgg7zWO1CxUdei7vWoPg91Lz2aYavh9.f9q0e4bRadue", "USER"));
		// Username: admin, password: admin
		userRepository.save(
            new AppUser("admin","$2a$10$8cjz47bjbR4Mn8GMg9IZx.vyjhLXR/SKKMSZ9.mP9vpMu0ssKi8GW", "ADMIN"));
	}
}
```

<hr>

4-6) Check

Now you will get a 401 Unauthorized error if you try to send a GET request to the http://localhost:8080/api path without authentication. 
You must authenticate to be able to send a successful request.

Use basic auth in header, input username and password
![basic auth of spring security](https://github.com/Elliot518/mcp-oss-repo/blob/main/backend/springsecurity/basic_auth.png?raw=true)

&nbsp;

### 5. Securing backend with JWT

- Drawbacks of basic authentication 

	It doesn’t provide a way to handle tokens or manage sessions. When a user logs 
	in, the credentials are sent with each request, which can cause session management challenges and potential security risks.

<hr>

-  JSON Web Token (JWT)

	> JWTs (https://jwt.io/) are commonly used in RESTful APIs for authentication and authorization purposes. They are a compact way to implement authentication in modern web applications. A JWT is really small in size and can therefore be sent in the URL, in the POST parameter, or inside the header. It also contains all the necessary information about the user, such as their username and role.

	- Elements of JWT
	
		1. Header: The first part is the header, which defines the type of token and the hashing algorithm

		2. Payload: The second part is the payload, which, typically, in the case of authentication, contains user information

		3. Signature: The third part is the signature, which is used to verify that the token hasn’t been changed along the way

	_(eg: Header.Payload.Signature)_

#### How to implement JWT in SpringBoot

#### 5-1) add jwt dependencies

build.gradle
```groovy
dependencies {
	...
	implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
	runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5', 'io.jsonwebtoken:jjwt-jackson:0.11.5'
}
```

_We will use jjwt (https://github.com/jwtk/jjwt), which is the JWT library for Java and Android for creating and parsing JWTs._


<hr>

#### 5-2) create a class that generates and verifies a signed JWT

JwtService.java
```java
import org.springframework.stereotype.Component;

@Component
public class JwtService {
	// 1 day in ms. Should be shorter in production
	static final long EXPIRATIONTIME = 86400000; 
	
	static final String PREFIX = "Bearer";
}
```

A JWT is sent in the Authorization header and the content of the header looks like the following when using the Bearer schema:
```json
Authorization: Bearer <token>
```

<hr>

#### 5-3) create a secret key using the jjwt library’s secretKeyFor method


_This is only for demonstration purposes. In a production environment, you should read your secret key from the application configuration._



```java
/**
	The getToken method then generates and returns the token. The getAuthUser method gets the token from the response Authorization header. 
	Then, we will use the parserBuilder method provided by the jjwt library to create a JwtParserBuilder instance. The setSigningKey method is used to specify a secret key for token verification. The parseClaimsJws method removes the Bearer prefix from the Authorization header. Finally, we will use the getSubject method to get the username.
 */
public class JwtService {
	...

	// Generate secret key. Only for demonstration purposes.
 	// In production, you should read it from the application configuration.
 	static final Key key = Keys.secretKeyFor (SignatureAlgorithm.HS256);

 	// Generate signed JWT token
	public String getToken(String username) {
		String token = Jwts.builder()
			.setSubject(username)
			.setExpiration(new Date(System.currentTimeMillis() +
			EXPIRATIONTIME))
			.signWith(key)
			.compact(); 
	
		return token;
	}

	// Get a token from request Authorization header,
	// verify the token, and get username
	public String getAuthUser(HttpServletRequest request) {
		String token = request.getHeader(HttpHeaders.AUTHORIZATION);

		if (token != null) {
			String user = Jwts.parserBuilder()
				.setSigningKey(key)
				.build()
				.parseClaimsJws(token.replace(PREFIX, ""))
				.getBody()
				.getSubject();

			if (user != null)
				return user;
		}

		return null;
	}
}
```

<hr>

#### 5-4) add a new class to store credentials for authentication

_We can use a Java record, which was introduced in Java 14. A record is a good choice if you need a class that only holds data.The record has two fields: username and password, and we don’t have to write getters and setters when using it._
```java
public record AccountCredentials(String username, String password) 
{}
```

<hr>

#### 5-5) implement the controller class for login

_Login is done by calling the /login endpoint using the POST method and sending the username and password inside the request body._

LoginController.java
```java
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import com.packt.cardatabase.domain.AccountCredentials;
import com.packt.cardatabase.service.JwtService;

@RestController
public class LoginController {
	private final JwtService jwtService;
	private final AuthenticationManager authenticationManager;

	public LoginController(JwtService jwtService, AuthenticationManager authenticationManager) {
		this.jwtService = jwtService;
		this.authenticationManager = authenticationManager;
	}

	@PostMapping("/login")
	public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {
		// Generate token and send it in the response Authorization
		// header
	}
}
```

<hr>

#### implement the getToken method that handles the login functionality

```java
/*
	Get a JSON object from the request body that contains the username and password. 
	AuthenticationManager is used to perform authentication and it uses credentials that 
	we get from the request. 
	Then, we use the JwtService class’ getToken method to generate a JWT. 
	Finally, we build an HTTP response that contains the generated JWT in the Authorization header
*/
@PostMapping("/login")
public ResponseEntity<?> getToken(@RequestBody AccountCredentials credentials) {
	UsernamePasswordAuthenticationToken creds = new UsernamePasswordAuthenticationToken(
		credentials.username(), credentials.password());
	Authentication auth = authenticationManager.authenticate(creds);

	// Generate token
	String jwts = jwtService.getToken(auth.getName());

	// Build response with the generated token
	return ResponseEntity.ok().header(HttpHeaders.AUTHORIZATION, "Bearer" + jwts)
		.header(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS,"Authorization").build();
}
```


<hr>

#### 5-6) add AuthenticationManager in  SecurityConfig class

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;

...

@Configuration
@EnableWebSecurity
public class SecurityConfig {

	...


	@Bean
	public AuthenticationManager uthenticationManager(AuthenticationConfiguration authConfig) 
		throws Exception {
		return authConfig.getAuthenticationManager();
	}
 }
```

<hr>

#### 5-7) Add the filterChain method to the SecurityConfig class

> Spring Security’s SecurityFilterChain bean defines which paths are secured and which are not.

- eg: POST method request to the /login endpoint is allowed without authentication 
and that requests to all other endpoints require authentication
	```java
	// SecurityConfig.java
	// Add the following import
	import org.springframework.security.web.SecurityFilterChain;

	// Add filterChain method
	@Bean
	public SecurityFilterChain filterChain(HttpSecurity http) 
		throws Exception {
		http.csrf((csrf) -> csrf.disable())
			.sessionManagement((sessionManagement) -> sessionManagement.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
			.authorizeHttpRequests((authorizeHttpRequests) -> authorizeHttpRequests.requestMatchers(HttpMethod.POST,
			"/login").permitAll().anyRequest().authenticated());
		
		return http.build();
	}
	```

	_PS: We define that Spring Security will never create a session, and therefore we can disable cross-site request forgery (csrf). JWTs are designed to be stateless, which reduces the risk of session-related vulnerabilities._

<hr>

#### 5-8) Test login functionality

Open Postman and make a POST request to the URL: http://localhost:8080/login 
![](https://github.com/Elliot518/mcp-oss-tech/blob/main/backend/springboot/security/jwt_login.png?raw=true)

_If all goes well you should see an Authorization header in the response that contains 
the signed JWT_

&nbsp;

### 6. Securing the other requests

> Let's move on to handling authentication for the rest of the incoming requests.

In the authentication process, we use filters that allow us to perform some operations before a request goes to the controller or before a response is sent to a client.

#### 6-1) Use a filter class to authenticate all other incoming requests

Create a new class called AuthenticationFilter which extends Spring Security’s OncePerRequestFilter interface, the interface provides a doFilterInternal method where we could implement our authentication.

We inject a JwtService instance into the filter class to verify a token from the 
request. The SecurityContextHolder is where Spring Security stores the details of the 
authenticated user.
- AuthenticationFilter.java
	```java
	public class AuthenticationFilter extends OncePerRequestFilter {
		private final JwtService jwtService;

		public AuthenticationFilter(JwtService jwtService) {
			this.jwtService = jwtService;
		}

		@Override
		protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
				throws ServletException, java.io.IOException {
			// Get token from the Authorization header
			String jws = request.getHeader(HttpHeaders.AUTHORIZATION);
			if (jws != null) {
				// Verify token and get user
				String user = jwtService.getAuthUser(request);
				// Authenticate
				Authentication authentication = new UsernamePasswordAuthenticationToken(user, null,
						java.util.Collections.emptyList());
				SecurityContextHolder.getContext().setAuthentication(authentication);
			}
			filterChain.doFilter(request, response);
		}
	}
	```

<hr>

#### 6-2) Add our filter class to the Spring Security configuration

Inject the AuthenticationFilter class that we've just implemented to the SecurityConfig class
- SecurityConfig.java
	```java
	public class SecurityConfig {
		...

		private final AuthenticationFilter authenticationFilter;

		public SecurityConfig(UserDetailsServiceImpl userDetailsService, AuthenticationFilter authenticationFilter) {
			...
			this.authenticationFilter = authenticationFilter;
		}

	}
	```

<hr>

#### 6-3) Modify the filterChain method in the SecurityConfig class and add core filtering logic
- SecurityConfig.java
	```java
	public class SecurityConfig {
		...

		@Bean
		public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
			...

			http.csrf((csrf) -> csrf.disable()).cors(withDefaults())
					...
					.authorizeHttpRequests(...)
					.addFilterBefore(authenticationFilter, UsernamePasswordAuthenticationFilter.class);
			
			return http.build();
		}

	}
	```

<hr>

#### 6-4) Verify log in by calling the /login endpoint with the POST method
After a successful login, we will receive a JWT in the Authorization header

_Remember to add a valid user inside the body and set the Content-Type header to application/json if it is not done automatically by Postman_

![login request](https://github.com/Elliot518/mcp-oss-tech/blob/main/backend/springboot/security/jwt_login_request.png?raw=true)

<hr>

#### 6-5) Call the other RESTful service endpoints by sending the JWT that was received from the login in the Authorization header

![call with jwt](https://github.com/Elliot518/mcp-oss-tech/blob/main/backend/springboot/security/call_api_jwt.png?raw=true)

&nbsp;

### 7. Handling exceptions

We should also handle exceptions in the authentication. At the moment, if you try to log in using the wrong password, you get a 403 Forbidden status without any further clarification.


**Spring Security provides an AuthenticationEntryPoint interface that can be used to handle exceptions**

#### 7-1) Create a new class named AuthEntryPoint in the root package that implements AuthenticationEntryPoint interface


We implement the commence method, which gets an exception as a parameter. In the case of an exception, we set the response status to 401 Unauthorized and write an exception message to the response body.

- AuthEntryPoint.java
	```java
	public class AuthEntryPoint implements AuthenticationEntryPoint {
		@Override
		public void commence(HttpServletRequest request, HttpServletResponse response,
				AuthenticationException authException) throws IOException, ServletException {
			response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
			response.setContentType(MediaType.APPLICATION_JSON_VALUE);
			PrintWriter writer = response.getWriter();
			writer.println("Error: " + authException.getMessage());
		}
	}
	```

<hr>

#### 7-2) Configure Spring Security for the exception handling

_Inject your AuthEntryPoint class just implemented into the SecurityConfig class_

- SecurityConfig.java
	```java
	...
	private final AuthEntryPoint exceptionHandler;

	public SecurityConfig(..., AuthEntryPoint exceptionHandler) {
		...
		this.exceptionHandler = exceptionHandler;
	}
	```

<hr>

#### 7-3) Modify the filterChain method add exception handler

- SecurityConfig.java
	```java
	public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
		http.csrf((csrf) -> csrf.disable())
			...
			.exceptionHandling((exceptionHandling) -> exceptionHandling.authenticationEntryPoint(exceptionHandler));

		return http.build();
	}
	```

- Test the effect

	_If you send a login POST request with the wrong credentials, you will get a 401 
	Unauthorized status in the response and an error message in the body_

	![unauthorized error](https://github.com/Elliot518/mcp-oss-tech/blob/main/backend/springboot/security/unauthorized_error.png?raw=true)

&nbsp;

### 8. Adding a CORS filter

> CORS is cross-origin resource sharing, CORS introduces certain headers that help the client and server decide if cross-origin requests should be allowed or denied.


_The CORS filter is needed for the frontend, which is sending 
requests from the other origin. The CORS filter intercepts requests, and if these are identified as cross-origin, it adds proper headers to the request. For that, we will use Spring Security’s CorsConfigurationSource interface._

#### 8-1) Add corsConfigurationSource bean method to SecurityConfig class

- SecurityConfig.java
```java
@Bean
public CorsConfigurationSource corsConfigurationSource() {
	UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
	CorsConfiguration config = new CorsConfiguration();
	config.setAllowedOrigins(Arrays.asList("*"));
	config.setAllowedMethods(Arrays.asList("*"));
	config.setAllowedHeaders(Arrays.asList("*"));
	config.setAllowCredentials(false);
	config.applyPermitDefaultValues();
	source.registerCorsConfiguration("/**", config);
	return source;
}
```

<hr>

#### 8-2) Add the cors() function to the filterChain method

- SecurityConfig.java
```java
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
	http.csrf((csrf) -> csrf.disable())
		.cors(withDefaults())

	...

	return http.build();
}
```


